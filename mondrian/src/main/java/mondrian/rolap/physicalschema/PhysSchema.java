package mondrian.rolap.physicalschema;

import mondrian.rolap.RolapConnection;
import mondrian.rolap.RolapConnectionProps;
import mondrian.rolap.aggmatcher.JdbcSchema;
import org.eclipse.daanse.db.dialect.api.Datatype;
import org.eclipse.daanse.db.dialect.api.Dialect;
import org.eclipse.daanse.olap.api.Context;
import org.eigenbase.xom.NodeDef;

import java.sql.PreparedStatement;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Collection of relations and links (relationships) between them.
 *
 * <p>The directed graph formed by the relations and links is connected and
 * acyclic: there is a unique path from any relation to any other relation,
 * following a sequence of links in the appropriate direction.
 */
public class PhysSchema {
    // We use a linked hash map for determinacy; the order that tables are
    // declared doesn't matter (except that if there are duplicates, the
    // later one will be discarded).
    final LinkedHashMap<String, PhysRelation> tablesByName =
        new LinkedHashMap<String, PhysRelation>();
    final JdbcSchema jdbcSchema;

    final Set<PhysLink> linkSet = new HashSet<PhysLink>();

    private final Map<PhysRelation, List<PhysLink>> hardLinksFrom =
        new HashMap<PhysRelation, List<PhysLink>>();

    private int nextAliasId = 0;

    private final PhysSchemaGraph schemaGraph =
        new PhysSchemaGraph(
            this, Collections.<PhysLink>emptyList());

    private int columnCount;

    public final PhysStatistic statistic;

    private final Dialect dialect;
    /**
     * Creates a physical schema.
     *
     * @param dialect Dialect
     * @param internalConnection Internal connection (for data source, and
     *                           accounting of stats queries)
     * @param dataServicesProvider DataServicesProvider to supply
     *                             JdbcSchemaFactory
     */
    public PhysSchema(
        Context context,
        Dialect dialect,
        RolapConnectionProps connectionProps,
        RolapConnection internalConnection) throws SQLException {
        this.dialect = dialect;
        this.jdbcSchema =
            JdbcSchema.makeDB(
                internalConnection.getDataSource());
        jdbcSchema.load(connectionProps);
        statistic = new PhysStatistic(context, dialect, internalConnection);
    }

    /**
     * Adds a link to this schema.
     *
     * @param sourceKey Key (usually primary) of source table
     * @param targetRelation Target table (contains foreign key)
     * @param columnList List of foreign key columns
     * @param hard Whether the link is hard; that is, whether a join over
     * the link should be generated every time the source of the link is
     * referenced
     * @return whether the link was added (per {@link Set#add(Object)})
     */
    public boolean addLink(
        PhysKey sourceKey,
        PhysRelation targetRelation,
        List<PhysColumn> columnList,
        boolean hard)
    {
        final PhysLink physLink =
            new PhysLink(sourceKey, targetRelation, columnList);
        if (hard) {
            List<PhysLink> list = hardLinksFrom.get(targetRelation);
            if (list == null) {
                list = new ArrayList<PhysLink>(1);
                hardLinksFrom.put(targetRelation, list);
            }
            list.add(physLink);
        }
        if (linkSet.add(physLink)) {
            this.schemaGraph.addLink(physLink);
            return true;
        } else {
            return false;
        }
    }

    public List<PhysLink> hardLinksFrom(PhysRelation from) {
        Util.deprecated("not used - remove", false);
        final List<PhysLink> linkList = hardLinksFrom.get(from);
        if (linkList == null) {
            return Collections.emptyList();
        } else {
            return linkList;
        }
    }

    /**
     * Generates a new alias, distinct from aliases of relations registered
     * in this schema and other aliases that have been generated by this
     * method for this schema.
     *
     * <p>There is no guarantee that a relation will not be subsequently
     * registered with a matching user-defined alias, but this is unlikely.
     *
     * @return Unique relation alias
     */
    public String newAlias() {
        while (true) {
            String alias = "_" + nextAliasId++;
            if (!tablesByName.containsKey(alias)) {
                return alias;
            }
        }
    }

    /**
     * Returns the default graph for this schema. The graph contains all
     * relations and links.
     *
     * @return Default graph
     */
    public PhysSchemaGraph getGraph() {
        return schemaGraph;
    }

    public int getColumnCount() {
        return columnCount;
    }

    public void setColumnCount(int columnCount) {
        this.columnCount = columnCount;
    }


    public Datatype sqlTypeToDatatype(
        String typeName,
        int type)
    {
        mondrian.olap.Util.discard(typeName); // not used, but reserved for future use
        switch (type) {
            case Types.BINARY:
                // REVIEW: Access returns BINARY when it encounters a NULL; we can
                // treat that as any type, so we arbitrarily choose INTEGER.
                return Datatype.INTEGER;
            case Types.BIT:
                return Datatype.INTEGER;
            case Types.BOOLEAN:
                return Datatype.BOOLEAN;
            case Types.DATE:
                return Datatype.DATE;
            case Types.TINYINT:
            case Types.SMALLINT:
            case Types.INTEGER:
            case Types.BIGINT:
                return Datatype.INTEGER;
            case Types.NUMERIC:
            case Types.DECIMAL:
            case Types.FLOAT:
            case Types.DOUBLE:
                return Datatype.NUMERIC;
            case Types.CHAR:
            case Types.VARCHAR:
                return Datatype.STRING;
            case Types.TIME:
                return Datatype.TIME;
            case Types.TIMESTAMP:
                return Datatype.TIMESTAMP;
            default:
                return null;
        }
    }
    List<ColumnInfo> describe(
        RolapSchemaLoader loader,
        NodeDef xmlNode,
        String sql)
    {
        java.sql.Connection connection = null;
        PreparedStatement pstmt = null;
        try {
            connection =
                jdbcSchema.getDataSource().getConnection();
            pstmt = connection.prepareStatement(sql);
            final ResultSetMetaData metaData = pstmt.getMetaData();
            final int columnCount = metaData.getColumnCount();
            final List<ColumnInfo> columnInfoList =
                new ArrayList<ColumnInfo>();
            for (int i = 0; i < columnCount; i++) {
                final String columnName =  metaData.getColumnName(i + 1);
                final String typeName = metaData.getColumnTypeName(i + 1);
                final int type = metaData.getColumnType(i + 1);
                // REVIEW: We want the physical size of the column in bytes.
                //  Ideally it would be comparable with the value returned
                //  from DatabaseMetaData.getColumns for a base table.
                final int columnSize = metaData.getColumnDisplaySize(i + 1);
                assert columnSize > 0;
                final Datatype datatype =
                    sqlTypeToDatatype(typeName, type);
                if (datatype == null) {
                    loader.getHandler().warning(
                        "Unknown data type "
                            + typeName + " (" + type + ") for column "
                            + columnName + " of view; mondrian is probably"
                            + " not familiar with this database's type"
                            + " system");
                    continue;
                }
                columnInfoList.add(
                    new ColumnInfo(columnName, datatype, columnSize));
            }
            pstmt.close();
            pstmt = null;
            connection.close();
            connection = null;
            return columnInfoList;
        } catch (SQLException e) {
            loader.getHandler().warning(
                "View is invalid: " + e.getMessage() + "\nSQL: " + sql);
            return null;
        } finally {
            //noinspection ThrowableResultOfMethodCallIgnored
            mondrian.olap.Util.close(null, pstmt, connection);
        }
    }

    public LinkedHashMap<String, PhysRelation> getTablesByName() {
        return tablesByName;
    }

    public JdbcSchema getJdbcSchema() {
        return jdbcSchema;
    }

    public Set<PhysLink> getLinkSet() {
        return linkSet;
    }

    public Map<PhysRelation, List<PhysLink>> getHardLinksFrom() {
        return hardLinksFrom;
    }

    public int getNextAliasId() {
        return nextAliasId;
    }

    public PhysSchemaGraph getSchemaGraph() {
        return schemaGraph;
    }

    public PhysStatistic getStatistic() {
        return statistic;
    }

    public Dialect getDialect() {
        return dialect;
    }
}
