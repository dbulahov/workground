package mondrian.rolap.physicalschema;

import mondrian.olap.RoleImpl;
import mondrian.rolap.RolapConnectionProps;
import mondrian.rolap.RolapCubeHierarchy;
import mondrian.rolap.RolapHierarchy;
import mondrian.rolap.RolapMember;
import mondrian.rolap.RolapSchema;
import mondrian.rolap.SchemaKey;
import mondrian.rolap.SqlStatement;
import org.eclipse.daanse.db.dialect.api.Datatype;
import org.eclipse.daanse.db.dialect.api.Dialect;
import org.eclipse.daanse.olap.api.Context;
import org.eclipse.daanse.olap.api.access.Access;
import org.eclipse.daanse.olap.impl.UnmodifiableArrayMap;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingAutoGeneratedDateTable;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingCalculatedColumnDef;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingColumn;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingColumnDef;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingColumnDefs;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingCube;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingExpression;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingExpressionView;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingHint;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingKey;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingParameter;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingPhysicalSchema;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingPhysicalSchemaElement;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingPrivateDimension;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingSQL;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingSchema;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingTableElement;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingTimeDomain;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingUserDefinedFunction;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.RealOrCalcColumnDef;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.enums.TypeEnum;
import org.eclipse.daanse.olap.rolap.dbmapper.model.record.ColumnDefR;
import org.eclipse.daanse.olap.rolap.dbmapper.model.record.SQLR;
import org.eclipse.daanse.olap.rolap.dbmapper.model.record.TimeDomainR;
import org.eigenbase.xom.NodeDef;
import org.eigenbase.xom.TextDef;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Pattern;

import static com.univocity.parsers.common.ArgumentUtils.trim;
import static mondrian.rolap.physicalschema.Util.first;
import static org.eclipse.daanse.olap.api.result.Olap4jUtil.enumSetOf;

public class RolapSchemaLoader {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(RolapSchemaLoader.class);

    private static final Set<Access> schemaAllowed =
        enumSetOf(
            Access.NONE,
            Access.ALL,
            Access.ALL_DIMENSIONS,
            Access.CUSTOM);

    private static final Set<Access> cubeAllowed =
        enumSetOf(Access.NONE, Access.ALL, Access.CUSTOM);

    private static final Set<Access> dimensionAllowed =
        enumSetOf(Access.NONE, Access.ALL, Access.CUSTOM);

    private static final Set<Access> hierarchyAllowed =
        enumSetOf(Access.NONE, Access.ALL, Access.CUSTOM);

    private static final Set<Access> memberAllowed =
        enumSetOf(Access.NONE, Access.ALL);

    private static final String EMPTY_TABLE_NAME = "_empty";
    private static final String EMPTY_TABLE_SOLE_COLUMN_NAME = "c";
    private static final Pattern PROTOCOL_PATTERN = Pattern.compile("[a-z]+:");
    private final List<RolapMember> measureList = new ArrayList<RolapMember>();
    private final List<RolapMember> aggFactCountMeasureList =
        new ArrayList<RolapMember>();

    /** Deferred actions to assign default members of hierarchies, for the
     * cube currently being loaded. */
    private final List<AssignDefaultMember> assignDefaultMembers =
        new ArrayList<AssignDefaultMember>();
    private final Map<RolapHierarchy, List<RolapCubeHierarchy>> cubeHierMap =
        new HashMap<RolapHierarchy, List<RolapCubeHierarchy>>();
    private final List<Util.Function0> postCubeActions =
        new ArrayList<Util.Function0>();
    /**
     * Intentionally not static. SimpleDateFormat is not thread-safe.
     * RolapSchemaLoader always operates on a single thread.
     */
    private final SimpleDateFormat SIMPLE_DATE_FORMAT =
        new SimpleDateFormat("yyyy-MM-dd");

    private static final RoleFactory DUMMY_ROLE =
        new ConstantRoleFactory(new RoleImpl());

    private RolapSchema schema;
    private final Context context;
    private final RolapConnectionProps connectionProps;
    private PhysSchemaBuilder physSchemaBuilder;
    private MissingLinkAction missingLinkAction;
    private final Handler handler =
        new RolapSchemaLoaderHandlerImpl() {
            protected List<Exception> getWarningList() {
                return schema == null ? null : schema.warningList;
            }
        };

    /**
     * Creates a RolapSchemaLoader.
     *
     * @param schema Schema being loaded (may be null, and populated later)
     */
    private RolapSchemaLoader(Context context, RolapConnectionProps connectionProps, RolapSchema schema) {
        this.context = context;
        this.connectionProps = connectionProps;
        this.schema = schema;
    }

    public static RolapSchema createSchema(
        SchemaKey key,
        RolapConnectionProps connectionProps,
        Context context

    ) {
        final RolapSchemaLoader schemaLoader = new RolapSchemaLoader(context, connectionProps, null);
        RolapSchema x = schemaLoader.loadStage0(
            key, context, connectionProps);
        schemaLoader.handler.check();
        return x;
    }


    /**
     * Loads the schema.
     *
     * <p>Called immediately after the RolapSchemaLoader's constructor. Creates
     * the schema, loads the catalog into DOM and builds application MDX and SQL
     * objects.
     *
     * @param key         Key
     * @return Populated schema
     */
    private RolapSchema loadStage0(
        final SchemaKey key,
        Context context,
        RolapConnectionProps connectionProps
    ) {
        assert schema == null;

        return loadStage1(
            key,
            connectionProps,
            context);
    }

    private RolapSchema loadStage1(
        SchemaKey key,
        RolapConnectionProps connectionProps,
        Context context

    ) {
        MappingSchema xmlSchema = context.getDatabaseMappingSchemaProviders().get(0).get();
        if (LOGGER.isDebugEnabled()) {
            StringWriter sw = new StringWriter(4096);
            PrintWriter pw = new PrintWriter(sw);
            pw.println("RolapSchema.load: dump xmlschema");
            pw.flush();
            LOGGER.debug(sw.toString());
        }

        // Load localized resources. (Needs to happen before we create Schema's
        // larder.)
        final Set<Locale> locales = new HashSet<Locale>();
        //loadResources(catalogDirUrl, xmlSchema, locales);

        schema =
            new RolapSchema(
                key,
                connectionProps,
                context);

        loadStage2(
            connectionProps,
            xmlSchema,
            xmlSchema.physicalSchema(),
            xmlSchema.userDefinedFunctions(),
            xmlSchema.dimensions(),
            xmlSchema.parameters(),
            xmlSchema.cubes());
        return schema;
    }

    void loadStage2(
        RolapConnectionProps connectionProps,
        MappingSchema xmlSchema,
        final MappingPhysicalSchema xmlPhysicalSchema,
        final List<MappingUserDefinedFunction> xmlUserDefinedFunctions,
        final List<MappingPrivateDimension> xmlDimensions,
        final List<MappingParameter> xmlParameters,
        final List<MappingCube> xmlCubes) {
        final Dialect dialect = schema.getDialect();
        schema.setPhysicalSchema(
            validatePhysicalSchema(
                xmlPhysicalSchema, getHandler(), dialect, schema));

    }

    private static Map<String, String> buildHintMap(
        List<MappingHint> hints
    ) {
        if (hints == null || hints.isEmpty()) {
            return Collections.emptyMap();
        }
        Map<String, String> hintMap = new HashMap<String, String>();
        for (MappingHint hint : hints) {
            hintMap.put(hint.type(), hint.content());
        }
        return hintMap;
    }

    private PhysSchema validatePhysicalSchema(
        MappingPhysicalSchema xmlPhysicalSchema,
        Handler handler,
        final Dialect dialect,
        final RolapSchema schema
    )  {
        if (xmlPhysicalSchema == null) {
            handler.error("Physical schema required");
            return null;
        }
        final PhysSchema physSchema =
            createSyntheticPhysicalSchema();

        // Create a table with 0 rows and 1 column. It is the basis for hanger
        // dimensions.
        final PhysInlineTable empty =
            new PhysInlineTable(
                physSchema, EMPTY_TABLE_NAME);
        final PhysRealColumn c =
            new PhysRealColumn(
                empty, EMPTY_TABLE_SOLE_COLUMN_NAME, Datatype.INTEGER,
                null, -1);
        empty.columnsByName.put(c.name, c);
        physSchema.tablesByName.put(empty.alias, empty);

        this.physSchemaBuilder = new PhysSchemaBuilder(null, physSchema);

        final Set<RealOrCalcColumnDef> skip = new HashSet<>();

        // First pass through elements, creating tables, ensuring that
        // table names are unique.
        // Register columns explicitly defined and also load columns from JDBC.
        // Collect calculated columns, to be resolved later.
        List<UnresolvedColumn> unresolvedColumnList =
            new ArrayList<UnresolvedColumn>();
        for (MappingPhysicalSchemaElement relation : xmlPhysicalSchema.children()) {
            final PhysRelationImpl physTable;
            if (relation instanceof MappingAutoGeneratedDateTable mappingAutoGeneratedDateTable) {
                String alias = mappingAutoGeneratedDateTable.alias();
                physTable =
                    registerTable(
                        handler,
                        dialect,
                        physSchema,
                        skip,
                        unresolvedColumnList,
                        mappingAutoGeneratedDateTable.alias(),
                        mappingAutoGeneratedDateTable);

                // If the table's alias is not unique, let the previous alias
                // stand; this table will be thrown away, but this check is after
                // the column and key validation so we can produce as many warnings
                // as possible.
                if (physSchema.tablesByName.containsKey(alias)) {
                    handler.warning(
                        "Duplicate table alias '" + alias + "'.");
                } else {
                    physSchema.tablesByName.put(alias, physTable);
                }

            } else {
                handler.warning(
                    "Invalid element '"
                        + "' in physical schema");
                continue;
            }

        }


        // Third pass, validate calculated columns. Note that a calculated
        // column can reference columns in other tables. Forward references
        // are allowed, but references must not be cyclic.
        for (UnresolvedColumn unresolvedColumn
            : unresolvedColumnList) {
            if (unresolvedColumn.getState()
                == UnresolvedColumn.State.RESOLVED) {
                continue;
            }
            resolve(physSchema, unresolvedColumn);
        }

        // Validate keys.
        for (PhysRelation table : physSchema.tablesByName.values()) {
            for (PhysKey key : table.getKeyList()) {
                for (PhysExpr keyColumn : key.columnList) {
                    if (keyColumn instanceof PhysCalcColumn) {
                        PhysCalcColumn physCalcColumn =
                            (PhysCalcColumn) keyColumn;
                        handler.warning(
                            "Key must not contain calculated column; calculated"
                                + " column '" + physCalcColumn.name
                                + "' in table '"
                                + physCalcColumn.relation.getAlias() + "'.");
                    } else if (keyColumn
                        instanceof UnresolvedColumn) {
                        // have already reported that it is unresolved: continue
                    } else {
                        PhysRealColumn column =
                            (PhysRealColumn) keyColumn;
                        if (column.relation != table) {
                            handler.warning(
                                "Columns in primary key must belong to key "
                                    + "table; in table '" + table.getAlias() + "'.");
                        }
                    }
                }
            }
        }

        return physSchema;
    }

    void resolve(
        PhysSchema physSchema,
        UnresolvedColumn unresolvedColumn
    ) {
        try {
            if (unresolvedColumn.getState() == UnresolvedColumn.State.ACTIVE) {
                getHandler().warning(
                    "Calculated column '" + unresolvedColumn.getName()
                        + "' in table '" + unresolvedColumn.getTableName()
                        + "' has cyclic expression");
                return;
            }
            unresolvedColumn.setState(UnresolvedColumn.State.ACTIVE);
            final PhysRelation table =
                physSchema.tablesByName.get(unresolvedColumn.getTableName());
            if (table == null) {
                getHandler().warning(
                    "Unknown table '" + unresolvedColumn.getTableName() + "'"
                        + unresolvedColumn.getContext() + ".");
                return;
            }
            final PhysColumn column =
                table.getColumn(
                    unresolvedColumn.getName(), false);
            if (column == null) {
                getHandler().warning(
                    "Reference to unknown column '" + unresolvedColumn.getName()
                        + "' in table '" + unresolvedColumn.getTableName() + "'"
                        + unresolvedColumn.getContext() + ".");
            } else {
                if (column instanceof PhysCalcColumn) {
                    PhysCalcColumn physCalcColumn =
                        (PhysCalcColumn) column;
                    for (Object o : physCalcColumn.list) {
                        if (o instanceof UnresolvedColumn) {
                            resolve(
                                physSchema,
                                (UnresolvedColumn) o);
                        }
                    }
                }
                unresolvedColumn.setState(UnresolvedColumn.State.RESOLVED);
                unresolvedColumn.onResolve(column);
            }
        } finally {
            if (unresolvedColumn.getState() == UnresolvedColumn.State.ACTIVE) {
                unresolvedColumn.setState(UnresolvedColumn.State.ERROR);
            }
        }
    }

    /**
     * Creates a physical schema for a user schema that has no PhysicalSchema
     * element. (Such a schema is referred to elsewhere as an
     * 'old-style schema'.)
     *
     * @return Physical schema
     */
    private PhysSchema createSyntheticPhysicalSchema()  {
        return new PhysSchema(
            context,
            schema.getDialect(),
            connectionProps,
            schema.getInternalConnection());
    }

    private PhysTable registerTable(
        Handler handler,
        Dialect dialect,
        PhysSchema physSchema,
        Set<RealOrCalcColumnDef> skip,
        List<UnresolvedColumn> unresolvedColumnList,
        String alias,
        MappingAutoGeneratedDateTable xmlTable
    ) {
        final PhysTable physTable =
            new PhysTable(
                physSchema,
                xmlTable.schema(),
                xmlTable.name(),
                alias,
                null);

        if (xmlTable instanceof MappingAutoGeneratedDateTable) {
            registerAutoDateTable(handler, xmlTable, physTable);
            physTable.ensurePopulated(this);
        } else {
            // Read columns from JDBC.
            physTable.ensurePopulated(this);
            // First pass, register columns. We will resolve and
            // register keys later.
            for (RealOrCalcColumnDef xmlColumn
                : getRealOrCalcColumnDef(xmlTable.tableElement())) {
                registerColumn(
                    handler,
                    dialect,
                    skip,
                    unresolvedColumnList,
                    alias,
                    physTable,
                    xmlColumn);
            }
        }
        //TODO
        /*
        registerKey(
            handler, xmlTable, xmlTable.column(), null, unresolvedColumnList,
            physTable);
        for (MappingKey key : xmlTable.keys()) {
            registerKey(
                handler, xmlTable, null, key, unresolvedColumnList, physTable);
        }
         */
        return physTable;
    }

    private List<RealOrCalcColumnDef> getRealOrCalcColumnDef(List<MappingTableElement> children) {
        List<RealOrCalcColumnDef> result = new ArrayList<>();
        for (MappingTableElement child : children) {
            if (child instanceof MappingColumnDefs mappingColumnDefs) {
                result.addAll(mappingColumnDefs.columns());
            }
        }
        return result;
    }

    static class Tcl {
        private final String table;
        private final String column;
        private final MappingColumn xml;

        Tcl(String table, String column, MappingColumn xml) {
            this.table = table;
            this.column = column;
            this.xml = xml;
        }

        public String table() {
            return table;
        }
    }

    private void registerKey(
        Handler handler,
        MappingColumn xmlTable,
        String columnName,
        final MappingKey xmlKey,
        List<UnresolvedColumn> unresolvedColumnList,
        final PhysRelationImpl physTable)
    {
        String keyName;
        List<Tcl> columns;
        if (xmlKey == null) {
            if (columnName == null) {
                // If both null, nothing to do.
                return;
            }
            columns = Collections.singletonList(
                new Tcl(null, columnName, xmlTable));
            keyName = "primary";
        } else {
            columns = new AbstractList<Tcl>() {
                public Tcl get(int index) {
                    MappingColumn column = xmlKey.columns().get(index);
                    return new Tcl(column.table(), column.name(), column);
                }

                public int size() {
                    return xmlKey.columns().size();
                }
            };
            keyName = xmlKey.name();
            if (keyName == null) {
                keyName = "primary";
            }
        }
        if (physTable.lookupKey(keyName) != null) {
            handler.error(
                "Table has more than one key with name '" + keyName
                    + "'");
            return;
        }
        final PhysKey key =
            physTable.addKey(
                keyName, new ArrayList<PhysColumn>());
        int i = 0;
        for (Tcl columnRef : columns) {
            final int index = i++;
            final UnresolvedColumn unresolvedColumn =
                new UnresolvedColumn(
                    physTable,
                    columnRef.table() != null
                        ? columnRef.table()
                        : physTable.alias,
                    columnRef.column,
                    columnRef.xml)
                {
                    public void onResolve(PhysColumn column) {
                        assert column != null;
                        key.columnList.set(index, column);
                    }

                    public String getContext() {
                        return ", in key of table '"
                            + physTable.alias + "'";
                    }
                };
            key.columnList.add(unresolvedColumn);
            unresolvedColumnList.add(unresolvedColumn);
        }
        if (key.columnList.size() != 1) {
            handler.warning(
                "Key must have precisely one column; key "
                    + key.columnList
                    + " in table '"
                    + physTable.alias + "'.");
        }
    }


    private void registerColumn(
        Handler handler,
        Dialect dialect,
        Set<RealOrCalcColumnDef> skip,
        List<UnresolvedColumn> unresolvedColumnList,
        String alias,
        PhysRelationImpl physRelation,
        RealOrCalcColumnDef xmlColumn
    ) {
        boolean inlineTable =
            physRelation instanceof PhysInlineTable;
        boolean calcColDef =
            xmlColumn instanceof MappingCalculatedColumnDef;
        if ((inlineTable || calcColDef)
            && physRelation.columnsByName.containsKey(xmlColumn.name())) {
            // The calc or inlined column is a duplicate.
            handler.warning(
                "Duplicate column '" + xmlColumn.name()
                    + "' in table '" + alias + "'.");
            skip.add(xmlColumn);
            return;
        }
        if (inlineTable) {
            PhysInlineTable physInlineTable =
                (PhysInlineTable) physRelation;
            if (calcColDef) {
                handler.warning(
                    "Cannot define calculated column in inline table");
            } else {
                PhysRealColumn physColumn =
                    new PhysRealColumn(
                        physInlineTable,
                        xmlColumn.name(),
                        toType(xmlColumn.type()),
                        toInternalType(xmlColumn.internalType()),
                        -1);
                physInlineTable.addColumn(physColumn);
            }
            return;
        }
        final PhysTable physTable =
            (PhysTable) physRelation;
        if (calcColDef) {
            MappingCalculatedColumnDef xmlCalcColumnDef =
                (MappingCalculatedColumnDef) xmlColumn;
            final List<PhysExpr> list =
                new ArrayList<PhysExpr>();
            final PhysCalcColumn physCalcColumn =
                new PhysCalcColumn(
                    this,
                    xmlCalcColumnDef,
                    physTable,
                    xmlColumn.name(),
                    toType(xmlColumn.type()),
                    toInternalType(xmlColumn.internalType()),
                    list);

            final MappingSQL sql;
            assert xmlCalcColumnDef.expression() != null;
            if (xmlCalcColumnDef.expression()
                instanceof MappingExpressionView) {
                MappingExpressionView expressionView =
                    (MappingExpressionView)
                        xmlCalcColumnDef.expression();
                sql = choose(
                    expressionView.sqls(),
                    dialect);
                list.add(new PhysTextExpr(sql.content()));
            } else if (xmlCalcColumnDef.expression()
                instanceof MappingColumn columnRef) {
                // Create dummy wrapper so it looks as if the
                // column is part of a collection of SQL
                // choices.
                final int index = list.size();
                final UnresolvedColumn unresolvedColumn =
                    new UnresolvedCalcColumn(
                        physTable,
                        first(columnRef.table(), alias),
                        columnRef,
                        physCalcColumn,
                        list,
                        index);
                list.add(unresolvedColumn);
                unresolvedColumnList.add(unresolvedColumn);
            } else {
                throw new IllegalArgumentException(
                    "illegal expression: ");
            }
            physCalcColumn.compute();
            physTable.addColumn(physCalcColumn);
        } else {
            // Check that column exists; throw if not.
            PhysColumn physColumn =
                physRelation.getColumn(
                    xmlColumn.name(),
                    true);
            if (xmlColumn.type() != null) {
                physColumn.setDatatype(
                    toType(xmlColumn.type()));
            }
            if (xmlColumn.internalType() != null) {
                physColumn.setInternalType(
                    toInternalType(xmlColumn.internalType()));
            }
        }
    }

    private MappingSQL choose(List<MappingSQL> sqls, Dialect dialect) {
        Optional<MappingSQL> result = sqls.stream().filter(s -> dialect.getDialectName().equals(s.dialect())).findFirst();
        if (!result.isPresent()) {
            result = sqls.stream().filter(s -> "generic".equals(s.dialect())).findFirst();
        }
        return result.orElseThrow(() -> new RuntimeException("Sql with dialect " + dialect.getDialectName() + "is absent"));
    }

    private static final Map<String, SqlStatement.Type> VALUES =
        UnmodifiableArrayMap.of(
            "int", SqlStatement.Type.INT,
            "double", SqlStatement.Type.DOUBLE,
            "Object", SqlStatement.Type.OBJECT,
            "String", SqlStatement.Type.STRING,
            "long", SqlStatement.Type.LONG);

    private static SqlStatement.Type toInternalType(String internalTypeName) {
        SqlStatement.Type type = VALUES.get(internalTypeName);
        if (type == null && internalTypeName != null) {
            throw mondrian.olap.Util.newError(
                "Invalid value '" + internalTypeName
                    + "' for attribute 'internalType' of element 'Level'. "
                    + "Valid values are: "
                    + VALUES.keySet());
        }
        return type;
    }

    private Datatype toType(TypeEnum type) {
            return Datatype.fromValue(type.getValue());
    }

    private void registerAutoDateTable(
        Handler handler,
        MappingPhysicalSchemaElement xmlTable,
        PhysTable physTable
    ) {
        MappingAutoGeneratedDateTable xmlDateTable =
            (MappingAutoGeneratedDateTable) xmlTable;
        final Map<String, TimeColumnRole.Struct> columnRoleMap =
            new HashMap<>();
        List<MappingColumnDef> xmlColumnDefs;
        if (hasColumnDefs(xmlDateTable.tableElement())) {
            xmlColumnDefs = getColumnDefs(xmlDateTable.tableElement());
        } else {
            xmlColumnDefs =
                new ArrayList<>();
            for (TimeColumnRole role : TimeColumnRole.values()) {
                MappingColumnDef xmlColumnDef =
                    new ColumnDefR(new TimeDomainR(role.name(), null), role.columnName,
                        TypeEnum.fromValue(role.defaultDatatype.name()), null);
                xmlColumnDefs.add(xmlColumnDef);
            }
        }
        for (MappingColumnDef xmlColumnDef : xmlColumnDefs) {
            MappingTimeDomain domain =
                xmlColumnDef.timeDomain();
            TimeColumnRole.Struct struct;
            if (domain != null) {
                TimeColumnRole role =
                    Util.lookup(
                        TimeColumnRole.class, domain.role().toUpperCase());
                if (role == null) {
                    handler.error(
                        "Bad role '" + domain + "', in column '"
                            + xmlColumnDef.name() + "'. Allowable roles are "
                            + Arrays.toString(TimeColumnRole.values()));
                    continue;
                }
                struct =
                    new TimeColumnRole.Struct(
                        role,
                        parseDate(domain.epoch(), domain, "epoch"));
            } else {
                TimeColumnRole role =
                    TimeColumnRole.mapNameToRole.get(
                        xmlColumnDef.name().toUpperCase());
                if (role == null) {
                    handler.error(
                        "Each column in an auto-generated date table must "
                            + "either have a nested <TimeDomain> element, or "
                            + "have a standard name such as 'the_month'; "
                            + "column '" + xmlColumnDef.name() + "' is neither");
                    continue;
                }
                struct = new TimeColumnRole.Struct(role, null);
            }
            if (xmlColumnDef.type() == null) {
                xmlColumnDef.setType(TypeEnum.fromValue(struct.role.defaultDatatype.getValue()));
            }
            columnRoleMap.put(xmlColumnDef.name(), struct);
        }
        Instant startDate = xmlDateTable.startDate();
        Instant endDate = xmlDateTable.endDate();
        //endDate
        if (startDate == null || endDate == null) {
            // parseDate has posted an error. Soldier on...
            return;
        }
        physTable.setHook(
            new DateTableBuilder(
                columnRoleMap,
                xmlColumnDefs, startDate, endDate));
    }

    private List<MappingColumnDef> getColumnDefs(List<MappingTableElement> children) {
        List<MappingColumnDef> result = new ArrayList<>();
        for (RealOrCalcColumnDef child : getRealOrCalcColumnDef(children)) {
            if (child instanceof MappingColumnDef mappingColumnDefs) {
                result.add(mappingColumnDefs);
            }
        }
        return result;

    }

    /**
     * Parses a date in "yyyy-MM-dd" format (e.g. "2012-02-21").
     *
     * <p>If date is
     * not valid, posts an error and returns null.</p>
     *
     * <p>If date is null, returns null.</p>
     *
     * @param dateString    Date string
     * @param node          XML node
     * @param attributeName XML attribute
     * @return Parsed date, or null if date string is null or not valid
     */
    private java.sql.Date parseDate(
        String dateString,
        MappingTimeDomain node,
        String attributeName
    ) {
        if (dateString == null) {
            return null;
        }
        try {
            Date date = SIMPLE_DATE_FORMAT.parse(dateString);
            return new java.sql.Date(date.getTime());
        } catch (ParseException e) {
            handler.error(
                "Invalid date '" + dateString + "'");
            return null;
        }
    }

    public Handler getHandler() {
        return handler;
    }

    /**
     * Returns whether there is a &lt;ColumnDefs&gt; element among
     * {@code children}.
     *
     * @param children Array of child nodes
     * @return Whether there is a ColumnDefs
     */
    private boolean hasColumnDefs(List<MappingTableElement> children) {
        for (MappingTableElement child : children) {
            if (child instanceof MappingColumnDefs) {
                return true;
            }
        }
        return false;
    }



    public RolapSchema getSchema() {
        return schema;
    }
}
