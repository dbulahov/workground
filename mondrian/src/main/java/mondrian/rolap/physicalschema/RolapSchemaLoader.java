package mondrian.rolap.physicalschema;

import mondrian.olap.DimensionType;
import mondrian.olap.FormulaImpl;
import mondrian.olap.IdImpl;
import mondrian.olap.RoleImpl;
import mondrian.olap.fun.UdfResolver;
import mondrian.olap.type.MemberType;
import mondrian.olap.type.NumericType;
import mondrian.olap.type.StringType;
import mondrian.resource.MondrianResource;
import mondrian.rolap.RolapAggregator;
import mondrian.rolap.RolapBaseCubeMeasure;
import mondrian.rolap.RolapConnectionProps;
import mondrian.rolap.RolapCube;
import mondrian.rolap.RolapCubeDimension;
import mondrian.rolap.RolapCubeHierarchy;
import mondrian.rolap.RolapDimension;
import mondrian.rolap.RolapHierarchy;
import mondrian.rolap.RolapLevel;
import mondrian.rolap.RolapMember;
import mondrian.rolap.RolapSchema;
import mondrian.rolap.RolapSchemaParameter;
import mondrian.rolap.RolapStar;
import mondrian.rolap.RolapStoredMeasure;
import mondrian.rolap.SchemaKey;
import mondrian.spi.impl.Scripts;
import mondrian.util.Composite;
import mondrian.util.Pair;
import org.apache.commons.math3.analysis.function.Exp;
import org.eclipse.daanse.db.dialect.api.Datatype;
import org.eclipse.daanse.db.dialect.api.Dialect;
import org.eclipse.daanse.olap.api.Context;
import org.eclipse.daanse.olap.api.DataType;
import org.eclipse.daanse.olap.api.Quoting;
import org.eclipse.daanse.olap.api.SchemaReader;
import org.eclipse.daanse.olap.api.access.Access;
import org.eclipse.daanse.olap.api.access.Role;
import org.eclipse.daanse.olap.api.access.RollupPolicy;
import org.eclipse.daanse.olap.api.element.Dimension;
import org.eclipse.daanse.olap.api.element.Hierarchy;
import org.eclipse.daanse.olap.api.element.Level;
import org.eclipse.daanse.olap.api.element.Member;
import org.eclipse.daanse.olap.api.element.NamedSet;
import org.eclipse.daanse.olap.api.query.component.Expression;
import org.eclipse.daanse.olap.api.query.component.Formula;
import org.eclipse.daanse.olap.api.query.component.Id;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingAnnotation;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingAutoGeneratedDateTable;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingCalculatedColumnDef;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingColumn;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingColumnDef;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingColumnDefs;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingCube;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingCubeDimension;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingCubeGrant;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingDimensionGrant;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingDimensionUsage;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingExpressionView;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingFormula;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingHierarchy;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingHierarchyGrant;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingHint;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingKey;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingMemberGrant;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingNamedSet;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingParameter;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingPhysicalSchema;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingPhysicalSchemaElement;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingPrivateDimension;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingRole;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingRoleUsage;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingSQL;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingSchema;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingSchemaGrant;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingTableElement;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingTimeDomain;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingUnion;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.MappingUserDefinedFunction;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.enums.AccessEnum;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.enums.DimensionTypeEnum;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.enums.MemberGrantAccessEnum;
import org.eclipse.daanse.olap.rolap.dbmapper.model.api.enums.TypeEnum;
import org.eclipse.daanse.olap.rolap.dbmapper.model.record.ColumnDefR;
import org.eclipse.daanse.olap.rolap.dbmapper.model.record.FormulaR;
import org.eclipse.daanse.olap.rolap.dbmapper.model.record.PrivateDimensionR;
import org.eclipse.daanse.olap.rolap.dbmapper.model.record.RoleR;
import org.eclipse.daanse.olap.rolap.dbmapper.model.record.SQLR;
import org.eclipse.daanse.olap.rolap.dbmapper.model.record.TimeDomainR;
import org.eigenbase.xom.DOMWrapper;
import org.eigenbase.xom.ElementDef;
import org.eigenbase.xom.NodeDef;
import org.eigenbase.xom.Parser;
import org.eigenbase.xom.TextDef;
import org.eigenbase.xom.XOMException;
import org.eigenbase.xom.XOMUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;

import static com.univocity.parsers.common.ArgumentUtils.trim;
import static mondrian.rolap.RolapSchema.toScriptDef;
import static mondrian.rolap.physicalschema.Util.first;
import static org.eclipse.daanse.olap.api.result.Olap4jUtil.enumSetOf;

public class RolapSchemaLoader {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(RolapSchemaLoader.class);

    private static final Set<Access> schemaAllowed =
        enumSetOf(
            Access.NONE,
            Access.ALL,
            Access.ALL_DIMENSIONS,
            Access.CUSTOM);

    private static final Set<Access> cubeAllowed =
        enumSetOf(Access.NONE, Access.ALL, Access.CUSTOM);

    private static final Set<Access> dimensionAllowed =
        enumSetOf(Access.NONE, Access.ALL, Access.CUSTOM);

    private static final Set<Access> hierarchyAllowed =
        enumSetOf(Access.NONE, Access.ALL, Access.CUSTOM);

    private static final Set<Access> memberAllowed =
        enumSetOf(Access.NONE, Access.ALL);

    private static final String EMPTY_TABLE_NAME = "_empty";
    private static final String EMPTY_TABLE_SOLE_COLUMN_NAME = "c";
    private static final Pattern PROTOCOL_PATTERN = Pattern.compile("[a-z]+:");
    private final List<RolapMember> measureList = new ArrayList<RolapMember>();
    private final List<RolapMember> aggFactCountMeasureList =
        new ArrayList<RolapMember>();

    /** Deferred actions to assign default members of hierarchies, for the
     * cube currently being loaded. */
    private final List<AssignDefaultMember> assignDefaultMembers =
        new ArrayList<AssignDefaultMember>();
    private final Map<RolapHierarchy, List<RolapCubeHierarchy>> cubeHierMap =
        new HashMap<RolapHierarchy, List<RolapCubeHierarchy>>();
    private final List<Util.Function0> postCubeActions =
        new ArrayList<Util.Function0>();
    /**
     * Intentionally not static. SimpleDateFormat is not thread-safe.
     * RolapSchemaLoader always operates on a single thread.
     */
    private final SimpleDateFormat SIMPLE_DATE_FORMAT =
        new SimpleDateFormat("yyyy-MM-dd");

    private static final RoleFactory DUMMY_ROLE =
        new ConstantRoleFactory(new RoleImpl());

    private RolapSchema schema;
    private Context context;
    private PhysSchemaBuilder physSchemaBuilder;
    private MissingLinkAction missingLinkAction;
    private final Handler handler =
        new RolapSchemaLoaderHandlerImpl() {
            protected List<Exception> getWarningList() {
                return schema == null ? null : schema.warningList;
            }
        };

    /**
     * Creates a RolapSchemaLoader.
     *
     * @param schema Schema being loaded (may be null, and populated later)
     */
    private RolapSchemaLoader(Context context, RolapSchema schema) {
        this.context = context;
        this.schema = schema;
    }

    public static RolapSchema createSchema(
        Context context,
        RolapConnectionProps connectionProps,
        SchemaKey key
    ) {
        final RolapSchemaLoader schemaLoader = new RolapSchemaLoader(context, null);
        RolapSchema x = schemaLoader.loadStage0(
            key, context, connectionProps);
        schemaLoader.handler.check();
        return x;
    }


    /**
     * Loads the schema.
     *
     * <p>Called immediately after the RolapSchemaLoader's constructor. Creates
     * the schema, loads the catalog into DOM and builds application MDX and SQL
     * objects.
     *
     * @param key         Key
     * @return Populated schema
     */
    private RolapSchema loadStage0(
        final SchemaKey key,
        Context context,
        RolapConnectionProps connectionProps
    ) {
        assert schema == null;

        return loadStage1(
            key,
            connectionProps,
            context);
    }

    private RolapSchema loadStage1(
        SchemaKey key,
        RolapConnectionProps connectionProps,
        Context context

    ) {
        MappingSchema xmlSchema = context.getDatabaseMappingSchemaProviders().get(0).get();
        if (LOGGER.isDebugEnabled()) {
            StringWriter sw = new StringWriter(4096);
            PrintWriter pw = new PrintWriter(sw);
            pw.println("RolapSchema.load: dump xmlschema");
            pw.flush();
            LOGGER.debug(sw.toString());
        }

        // Load localized resources. (Needs to happen before we create Schema's
        // larder.)
        final Set<Locale> locales = new HashSet<Locale>();
        //loadResources(catalogDirUrl, xmlSchema, locales);

        schema =
            new RolapSchema(
                key,
                connectionProps,
                context);

        loadStage2(
            connectionProps,
            xmlSchema,
            xmlSchema.physicalSchema(),
            xmlSchema.userDefinedFunctions(),
            xmlSchema.dimensions(),
            xmlSchema.parameters(),
            xmlSchema.cubes());
        return schema;
    }

    void loadStage2(
        RolapConnectionProps connectionProps,
        MappingSchema xmlSchema,
        final MappingPhysicalSchema xmlPhysicalSchema,
        final List<MappingUserDefinedFunction> xmlUserDefinedFunctions,
        final List<MappingPrivateDimension> xmlDimensions,
        final List<MappingParameter> xmlParameters,
        final List<MappingCube> xmlCubes)
    {
        final Dialect dialect = schema.getDialect();
        schema.setPhysicalSchema(
            validatePhysicalSchema(
                xmlPhysicalSchema, getHandler(), dialect, schema));

        // Validate user-defined functions. Must be done before we validate
        // calculated members, because calculated members will need to use the
        // function table.
        final Map<String, UdfResolver.UdfFactory> mapNameToUdf =
            new HashMap<String, UdfResolver.UdfFactory>();
        for (MappingUserDefinedFunction udf : xmlUserDefinedFunctions) {
            final Scripts.ScriptDefinition scriptDef = toScriptDef(udf.script());
            schema.defineFunction(
                mapNameToUdf, udf.name(), udf.className(), scriptDef);
        }
        schema.initFunctionTable(mapNameToUdf.values());

        // Create parameters.
        Set<String> parameterNames = new HashSet<String>();
        for (MappingParameter xmlParameter : xmlParameters) {
            String parameterName = xmlParameter.name();
            if (!parameterNames.add(parameterName)) {
                throw MondrianResource.instance().DuplicateSchemaParameter.ex(
                    parameterName);
            }
            org.eclipse.daanse.olap.api.type.Type type;
            if (xmlParameter.type().equals("String")) {
                type = StringType.INSTANCE;
            } else if (xmlParameter.type().equals("Numeric")) {
                type = NumericType.INSTANCE;
            } else {
                type = new MemberType(null, null, null, null);
            }
            final String description = xmlParameter.description();
            final boolean modifiable = toBoolean(xmlParameter.modifiable(), true);
            String defaultValue = xmlParameter.defaultValue();
            RolapSchemaParameter param =
                new RolapSchemaParameter(
                    schema, parameterName, defaultValue, description, type,
                    modifiable);
        }

        // Create cubes.
        for (MappingCube xmlCube : xmlCubes) {
            final RolapCube cube = createCube(schema, xmlCube, xmlSchema);
            if (cube == null) {
                continue;
            }

            for (Util.Function0 action : postCubeActions) {
                action.apply();
            }
            postCubeActions.clear();
        }

        // Create named sets.
        for (MappingNamedSet xmlNamedSet : xmlSchema.namedSets()) {
            schema.addNamedSet(
                xmlNamedSet.name(),
                createNamedSet(null, xmlNamedSet));
        }

        // Create roles.
        //
        // Union roles can depend on roles that occur later, so we iterate
        // until we reach a fixed point.
        Map<String, RoleFactory> rolesByName =
            new LinkedHashMap<String, RoleFactory>();
        for (MappingRole xmlRole : xmlSchema.roles()) {
            if (rolesByName.containsKey(xmlRole.name())) {
                handler.error(
                    "Duplicate role '" + xmlRole.name() + "'");
                continue;
            }
            rolesByName.put(xmlRole.name(), DUMMY_ROLE);
        }
        for (;;) {
            final int prevMapSize = rolesByName.size();
            MappingRole missed = null;
            for (MappingRole xmlRole : xmlSchema.roles()) {
                if (rolesByName.get(xmlRole.name()) != DUMMY_ROLE) {
                    continue;
                }
                final RoleFactory role =
                    createRole(xmlRole, rolesByName);
                if (role == DUMMY_ROLE) {
                    // Dependencies not resolved; cannot make progress.
                    missed = xmlRole;
                    continue;
                }
                rolesByName.put(xmlRole.name(), role);
            }
            if (missed == null) {
                break;
            }
            if (rolesByName.size() == prevMapSize) {
                handler.error(
                    "Role '" + missed.name() + "' has cyclic dependencies on "
                        + "other roles");
                break;
            }
        }

        RoleFactory defaultRole = null;
        if (xmlSchema.defaultRole() != null) {
            defaultRole = schema.mapNameToRole.get(xmlSchema.defaultRole());
            if (defaultRole == null) {
                handler.warning(
                    "Role '" + xmlSchema.defaultRole() + "' not found");
            }
        }
        if (defaultRole == null) {
            defaultRole = schema.getDefaultRole();
        }
        schema.registerRoles(rolesByName, defaultRole);

        // Set default role.

        schema.getAggTableManager().initialize(connectionProps);
        schema.setSchemaLoadDate();
    }

    RoleFactory createRole(
        MappingRole xmlRole,
        Map<String, RoleFactory> mapNameToRole)
    {
        final int count =
            (xmlRole.union() == null ? 0 : 1)
                + (xmlRole.schemaGrants().isEmpty() ? 0 : 1);
        if (count != 1) {
            if (false) {
                throw new AssertionError(
                    "Role must have precisely one of: className attribute, or "
                        + "Script, SchemaGrant, Union child elements");
            }
            throw MondrianResource.instance().RoleUnionGrants.ex();
        }
        if (xmlRole.union() != null) {
            return createUnionRole(mapNameToRole, xmlRole.union());
        } else {
            return createGrantRole(xmlRole.schemaGrants());
        }
    }

    private RoleFactory createGrantRole(
        List<MappingSchemaGrant> xmlSchemaGrants)
    {
        RoleImpl role = new RoleImpl();
        for (MappingSchemaGrant schemaGrant : xmlSchemaGrants) {
            role.grant(schema, getAccess(schemaGrant.access().name(), schemaAllowed));
            for (MappingCubeGrant cubeGrant : schemaGrant.cubeGrants()) {
                RolapCube cube = schema.lookupCube(cubeGrant.cube());
                if (cube == null) {
                    throw mondrian.olap.Util.newError(
                        "Unknown cube '" + cubeGrant.cube() + "'");
                }
                role.grant(cube, getAccess(cubeGrant.access(), cubeAllowed));
                final SchemaReader schemaReader = cube.getSchemaReader(null);
                for (MappingDimensionGrant dimensionGrant
                    : cubeGrant.dimensionGrants())
                {
                    Dimension dimension = (Dimension)
                        schemaReader.lookupCompound(
                            cube,
                            mondrian.olap.Util.parseIdentifier(dimensionGrant.dimension()),
                            true,
                            DataType.DIMENSION);
                    role.grant(
                        dimension,
                        getAccess(dimensionGrant.access().name(), dimensionAllowed));
                }
                for (MappingHierarchyGrant hierarchyGrant
                    : cubeGrant.hierarchyGrants())
                {
                    Hierarchy hierarchy = (Hierarchy)
                        schemaReader.lookupCompound(
                            cube,
                            mondrian.olap.Util.parseIdentifier(hierarchyGrant.hierarchy()),
                            true,
                            DataType.HIERARCHY);
                    final Access hierarchyAccess =
                        getAccess(hierarchyGrant.access().name(), hierarchyAllowed);
                    Level topLevel = null;
                    if (hierarchyGrant.topLevel() != null) {
                        if (hierarchyAccess != Access.CUSTOM) {
                            throw mondrian.olap.Util.newError(
                                "You may only specify 'topLevel' if "
                                    + "access='custom'");
                        }
                        topLevel = (Level) schemaReader.lookupCompound(
                            cube,
                            mondrian.olap.Util.parseIdentifier(hierarchyGrant.topLevel()),
                            true,
                            DataType.LEVEL);
                    }
                    Level bottomLevel = null;
                    if (hierarchyGrant.bottomLevel() != null) {
                        if (hierarchyAccess != Access.CUSTOM) {
                            throw mondrian.olap.Util.newError(
                                "You may only specify 'bottomLevel' if "
                                    + "access='custom'");
                        }
                        bottomLevel = (Level) schemaReader.lookupCompound(
                            cube,
                            mondrian.olap.Util.parseIdentifier(hierarchyGrant.bottomLevel()),
                            true,
                            DataType.LEVEL);
                    }
                    RollupPolicy rollupPolicy;
                    if (hierarchyGrant.rollupPolicy() != null) {
                        try {
                            rollupPolicy =
                                RollupPolicy.valueOf(
                                    hierarchyGrant.rollupPolicy().toUpperCase());
                        } catch (IllegalArgumentException e) {
                            throw mondrian.olap.Util.newError(
                                "Illegal rollupPolicy value '"
                                    + hierarchyGrant.rollupPolicy()
                                    + "'");
                        }
                    } else {
                        rollupPolicy = RollupPolicy.FULL;
                    }
                    role.grant(
                        hierarchy, hierarchyAccess, topLevel, bottomLevel,
                        rollupPolicy);
                    for (MappingMemberGrant memberGrant
                        : hierarchyGrant.memberGrants())
                    {
                        if (hierarchyAccess != Access.CUSTOM) {
                            throw mondrian.olap.Util.newError(
                                "You may only specify <MemberGrant> if "
                                    + "<Hierarchy> has access='custom'");
                        }
                        final boolean ignoreInvalidMembers =
                            MondrianProperties.instance().IgnoreInvalidMembers
                                .get();
                        Member member =
                            schemaReader.withLocus().getMemberByUniqueName(
                                mondrian.olap.Util.parseIdentifier(memberGrant.member()),
                                !ignoreInvalidMembers);
                        if (member == null) {
                            // They asked to ignore members that don't exist
                            // (e.g. [Store].[USA].[Foo]), so ignore this grant
                            // too.
                            assert ignoreInvalidMembers;
                            continue;
                        }
                        if (member.getHierarchy() != hierarchy) {
                            throw mondrian.olap.Util.newError(
                                "Member '" + member
                                    + "' is not in hierarchy '" + hierarchy + "'");
                        }
                        role.grant(
                            member,
                            getAccess(memberGrant.access().name(), memberAllowed));
                    }
                }
            }
        }
        role.makeImmutable();
        return new ConstantRoleFactory(role);
    }

    private static Access getAccess(String accessString, Set<Access> allowed) {
        final Access access = Access.valueOf(accessString.toUpperCase());
        if (allowed.contains(access)) {
            return access; // value is ok
        }
        throw mondrian.olap.Util.newError("Bad value access='" + accessString + "'");
    }

    private RoleFactory createUnionRole(
        Map<String, RoleFactory> mapNameToRole,
        MappingUnion xmlUnion)
    {
        List<RoleFactory> roleList =
            new ArrayList<RoleFactory>();
        for (MappingRoleUsage roleUsage : xmlUnion.roleUsages()) {
            final RoleFactory role =
                mapNameToRole.get(roleUsage.roleName());
            if (role == DUMMY_ROLE) {
                // dependency not resolved yet
                return DUMMY_ROLE;
            }
            if (role == null) {
                throw MondrianResource.instance().UnknownRole.ex(
                    roleUsage.roleName());
            }
            roleList.add(role);
        }
        return new UnionRoleFactory(roleList);
    }

    private NamedSet createNamedSet(
        RolapCube cube,
        MappingNamedSet xmlNamedSet)
    {
        final String formulaString = formula(xmlNamedSet);
        final Expression exp;
        try {
            exp = schema.getInternalConnection().parseExpression(formulaString);
        } catch (Exception e) {
            throw MondrianResource.instance().NamedSetHasBadFormula.ex(
                xmlNamedSet.name(), e);
        }
        final Formula formula =
            new FormulaImpl(
                new IdImpl(
                    new IdImpl.NameSegmentImpl(
                        xmlNamedSet.name(),
                        Quoting.UNQUOTED)),
                exp);
        return formula.getNamedSet();
    }

    private static String formula(MappingNamedSet xmlNamedSet) {
        final MappingFormula formula = xmlNamedSet.formulaElement();
        if (formula != null) {
            return formula.cdata();
        } else {
            return xmlNamedSet.formula();
        }
    }

    /**
     * Creates a cube.
     */
    private RolapCube createCube(
        RolapSchema schema,
        MappingCube xmlCube,
        MappingSchema xmlSchema)
    {
        if (!toBoolean(xmlCube.enabled(), true)) {
            return null;
        }
        if (schema.getCubeList().stream().filter(c -> c.getName().equals(xmlCube.name())).findFirst().isPresent()) {
            getHandler().error(
                "Duplicate cube '" + xmlCube.name() + "'");
            return null;
        }
        measureList.clear();
        aggFactCountMeasureList.clear();
        assignDefaultMembers.clear();
        cubeHierMap.clear();

        RolapCube cube =
            new RolapCube(
                this,
                xmlCube.name(),
                toBoolean(xmlCube.visible(), true),
                createLarder(
                    mondrian.olap.Util.quoteMdxIdentifier(xmlCube.name()) + ".cube",
                    xmlCube.annotations(),
                    xmlCube.name(),
                    xmlCube.caption(),
                    xmlCube.description()).build(),
                xmlSchema.measuresCaption());
        deferAssignDefaultMember(
            cube,
            cube.getMeasuresHierarchy(),
            xmlCube,
            xmlCube.defaultMeasure());

        //dimensionPaths.clear();

        final List<MappingCubeDimension> xmlCubeDimensions =
            xmlCube.dimensionUsageOrDimensions();

        final List<MappingCubeDimension> xmlCubeDimensionsPlus;

        xmlCubeDimensionsPlus = xmlCubeDimensions;


        int ordinal = cube.getDimensions().length;
        for (MappingCubeDimension xmlCubeDimension : xmlCubeDimensionsPlus) {
            // Look up usages of shared dimensions in the schema before
            // consulting the XML schema (which may be null).
            RolapCubeDimension dimension =
                getOrCreateDimension(
                    cube,
                    xmlCubeDimension,
                    schema,
                    xmlSchema,
                    ordinal++,
                    cube.getHierarchies(),
                    xmlCubeDimension.annotations());
            if (dimension == null) {
                continue;
            }

            cube.addDimension(dimension);
        }


        return cube;
    }

    /**
     * Creates a dimension from its XML definition. If the XML definition's
     * 'source' attribute is set, and the shared dimension is cached in the
     * schema, returns that.
     *
     *
     * @param xmlCubeDimension XML Dimension or DimensionUsage
     * @param schema Schema
     * @param xmlSchema XML Schema
     * @param dimensionOrdinal Ordinal of dimension
     * @param cubeHierarchyList List of hierarchies in cube
     * @param annotations Annotations
     * @return A dimension, or null if shared dimension does not exist
     */



    private RolapCubeDimension getOrCreateDimension(
        RolapCube cube,
        final MappingCubeDimension xmlCubeDimension,
        RolapSchema schema,
        final MappingSchema xmlSchema,
        int dimensionOrdinal,
        List<RolapHierarchy> cubeHierarchyList,
        final List<MappingAnnotation> annotations)
    {
        final String dimensionName = xmlCubeDimension.name();

        /*
        if (cube.dimensionList.get(dimensionName) != null) {
            getHandler().error(
                "Duplicate dimension '" + dimensionName + "'");
            return null;
        }
         */

        MappingCubeDimension xmlDimension ;
        DimensionType dimensionType = DimensionType.STANDARD_DIMENSION;
        if (xmlCubeDimension instanceof MappingDimensionUsage dimensionUsage ) {
            xmlDimension =
                useSharedDimension(cube, dimensionUsage, schema, xmlSchema);
            if (xmlDimension == null) {
                return null;
            }
        } else {
            xmlDimension = xmlCubeDimension;
            MappingPrivateDimension privateDimension = (MappingPrivateDimension) xmlDimension;
            dimensionType = privateDimension.type() == null ? DimensionType.STANDARD_DIMENSION :
                DimensionType.fromValue(privateDimension.type().getValue());
        }
        final RolapDimension dimension =
            new RolapDimension(
                schema,
                xmlDimension.name(),
                toBoolean(xmlDimension.visible(), true),
                dimensionType,
                xmlDimension.hanger(),
                createLarder(
                    mondrian.olap.Util.quoteMdxIdentifier(xmlDimension.name()) + ".dimension",
                    annotations,
                    xmlDimension.name(),
                    xmlDimension.caption(),
                    xmlDimension.description()).build());





        // Must add this dimension to the map of shared dimensions.
        // (it is bad practice to leak references to a constructed object
        // within its constructor, so we do it here.)
        if (xmlCubeDimension.source() != null
            && !schema.sharedDimensions.containsKey(dimension.getName()))
        {
            // Add a placeholder to prevent recursion.
            ((Map) schema.sharedDimensions).put(dimension.getName(), DUMMY);

            // Schedule an action for when we finish the current cube.
            postCubeActions.add(
                new mondrian.olap.Util.Function0() {
                    public Object apply() {
                        sharedDimension(
                            dimension, xmlCubeDimension.source, xmlSchema);
                        return null;
                    }
                });
        }

        // Load attributes before hierarchies, because levels refer to
        // attributes. Likewise create attributes before properties.
        final RolapSchema.PhysRelation dimensionRelation =
            xmlDimension.hanger
                ? getPhysRelation(EMPTY_TABLE_NAME, null, null)
                : xmlDimension.table == null
                ? null
                : getPhysRelation(
                xmlDimension.table, xmlDimension, "table");

        List<RolapAttribute> attributeList = new ArrayList<RolapAttribute>();
        for (MappingAttribute xmlAttribute : xmlDimension.getAttributes())
        {
            RolapAttribute attribute =
                createAttribute(
                    xmlAttribute, null, dimensionRelation, dimension);
            if (attribute == null) {
                continue;
            }
            RolapAttribute put =
                dimension.attributeMap.put(attribute.getName(), attribute);
            assert put == null : "validation rule should have caught dup attr";
            attributeList.add(attribute);
        }

        // Attributes and parent-child links.
        int attributeHierarchyCount = 0;
        for (RolapAttribute attribute : attributeList) {
            final MappingAttribute xmlAttribute =
                validator.getXml(attribute, true);

            createProperties(
                physSchemaBuilder,
                dimension,
                attribute,
                dimensionRelation,
                xmlAttribute,
                attribute.getExplicitProperties());
        }

        // Resolve key, if specified.
        //
        // Dimensions usually have a key. But they don't need one if they
        // are only going to be used as degenerate dimensions. So we will check
        // when the dimension is used.
        if (xmlDimension.key != null) {
            dimension.keyAttribute =
                dimension.attributeMap.get(xmlDimension.key);
            if (dimension.keyAttribute == null) {
                getHandler().error(
                    "Key attribute '"
                        + xmlDimension.key
                        + "' is not a valid attribute of this dimension",
                    xmlDimension,
                    "key");
                return null;
            }
            if (uniqueRelation(dimension) == null) {
                getHandler().error(
                    "Columns in key of dimension's key attribute '"
                        + xmlDimension.key
                        + "' do not belong to same relation",
                    xmlDimension,
                    "key");
                return null;
            }
        } else {
            // degenerate dim, should only be a single attribute
            if (attributeList.size() > 1) {
                getHandler().error(
                    MondrianResource.instance()
                        .DimensionKeyOmitted.ex(xmlDimension.name),
                    validator.getXmls(dimension),
                    null);
            }
            dimension.keyAttribute = attributeList.get(0);
        }

        // Use a Lazy variable to initialize dimension's key on first use.
        // Degenerate dimensions don't need keys.
        // But regular dimensions do, and they need to be validated using
        // information only available right here.
        dimension.key =
            new Lazy<RolapSchema.PhysKey>(
                new mondrian.olap.Util.Function0<RolapSchema.PhysKey>() {
                    public RolapSchema.PhysKey apply() {
                        return lookupKey(
                            xmlDimension, true, dimension.keyAttribute);
                    }
                }
            );

        for (MappingHierarchy xmlHierarchy : xmlDimension.getHierarchies())
        {
            // If hierarchy is not named, name is same as dimension.
            String hierarchyName = first(
                xmlHierarchy.name,
                xmlDimension.name);
            RolapHierarchy hierarchy =
                new RolapHierarchy(
                    dimension,
                    hierarchyName,
                    mondrian.olap.Util.makeFqName(dimension, hierarchyName),
                    toBoolean(xmlHierarchy.visible, true),
                    toBoolean(xmlHierarchy.hasAll, true),
                    null,
                    null,
                    createLarder(
                        mondrian.olap.Util.makeFqName(dimension, hierarchyName)
                            + ".hierarchy",
                        xmlHierarchy.getAnnotations(),
                        hierarchyName,
                        xmlHierarchy.caption,
                        xmlHierarchy.description).build());
            validator.putXml(hierarchy, xmlHierarchy);
            dimension.addHierarchy(hierarchy);
            hierarchy.initHierarchy(this, xmlHierarchy.allLevelName);
            if (xmlHierarchy.getLevels().size() == 0) {
                throw MondrianResource.instance().HierarchyHasNoLevels.ex(
                    hierarchy.getUniqueName());
            }
            for (MappingLevel xmlLevel : xmlHierarchy.getLevels()) {
                RolapLevel level =
                    createLevel(
                        cube,
                        hierarchy,
                        dimensionRelation,
                        hierarchy.levelList.size(),
                        xmlLevel);
                if (level == null) {
                    continue;
                }
                hierarchy.levelList.add(level);
            }
            deferAssignDefaultMember(
                cube, hierarchy, xmlHierarchy, xmlHierarchy.defaultMember);
        }

        for (RolapAttribute attribute : attributeList) {
            final MappingAttribute xmlAttribute =
                validator.getXml(attribute, true);
            if (toBoolean(
                xmlAttribute.hasHierarchy,
                countHierarchies(
                    dimension.getHierarchyList(), attribute) == 0))
            {
                if (dimension.getHierarchyList().get(xmlAttribute.name) != null)
                {
                    handler.error(
                        "Cannot create hierarchy for attribute '"
                            + xmlAttribute.name
                            + "'; dimension already has a hierarchy of that name",
                        xmlAttribute,
                        "name");
                    continue;
                }
                ++attributeHierarchyCount;
                // Create attribute hierarchy.
                final String uniqueName =
                    mondrian.olap.Util.makeFqName(dimension, xmlAttribute.name);
                RolapHierarchy hierarchy =
                    new RolapHierarchy(
                        dimension,
                        xmlAttribute.name,
                        uniqueName,
                        toBoolean(xmlAttribute.visible, true),
                        toBoolean(xmlAttribute.hierarchyHasAll, true),
                        null,
                        attribute,
                        createLarder(
                            cube + "." + uniqueName + ".hierarchy",
                            null,
                            xmlAttribute.name,
                            first(
                                xmlAttribute.hierarchyCaption,
                                xmlAttribute.caption),
                            xmlAttribute.description)
                            .populate(attribute.getLarder())
                            .build());
                dimension.addHierarchy(hierarchy);
                dimension.attributeMap.put(
                    attribute.getName(),
                    attribute);
                hierarchy.initHierarchy(
                    this,
                    hierarchy.hasAll()
                        ? xmlAttribute.hierarchyAllLevelName
                        : null);
                hierarchy.levelList.add(
                    new RolapLevel(
                        hierarchy,
                        xmlAttribute.name,
                        toBoolean(xmlAttribute.visible, true),
                        hierarchy.hasAll() ? 1 : 0,
                        attribute,
                        null,
                        attribute.getOrderByList(),
                        null,
                        null,
                        RolapLevel.HideMemberCondition.Never,
                        createLarder(
                            cube + "."
                                + mondrian.olap.Util.makeFqName(hierarchy, xmlAttribute.name)
                                + ".level",
                            null,
                            null,
                            null,
                            null)
                            .populate(
                                createLarder(
                                    cube + "."
                                        + mondrian.olap.Util.makeFqName(
                                        hierarchy, xmlAttribute.name)
                                        + ".level",
                                    xmlAttribute.getAnnotations(),
                                    xmlAttribute.name,
                                    xmlAttribute.caption,
                                    xmlAttribute.description).build())
                            .build(),
                        resourceMap));
                deferAssignDefaultMember(
                    cube, hierarchy, xmlAttribute,
                    xmlAttribute.hierarchyDefaultMember);
            }
        }

        if (dimension.getHierarchyList().isEmpty()
            && attributeHierarchyCount == 0)
        {
            getHandler().error(
                "Dimension '"
                    + dimension.getName()
                    + "' must have at least one hierarchy (or attribute "
                    + "hierarchy).",
                xmlDimension,
                null);
            return null;
        }

        validateDimensionType(dimension);

        // wrap the shared or regular dimension with a
        // rolap cube dimension object
        final RolapCubeDimension cubeDimension =
            new RolapCubeDimension(
                cube,
                dimension,
                dimensionName,
                dimensionOrdinal,
                createLarder(
                    cube.getUniqueName() + "."
                        + mondrian.olap.Util.quoteMdxIdentifier(dimensionName) + ".dimension",
                    xmlCubeDimension.getAnnotations(),
                    dimensionName,
                    first(xmlCubeDimension.caption, xmlDimension.caption),
                    first(
                        xmlCubeDimension.description,
                        xmlDimension.description))
                    .populate(dimension.getLarder())
                    .build());
        initCubeDimension(
            cubeDimension, xmlCubeDimension.source, cubeHierarchyList);
        validator.putXml(cubeDimension, xmlCubeDimension);

        // Populate attribute map. (REVIEW: Should attributes go ONLY in the
        // cube dimension?)
        cubeDimension.attributeMap.putAll(dimension.attributeMap);

        return cubeDimension;
    }


    private static Map<String, String> buildHintMap(
        List<MappingHint> hints
    ) {
        if (hints == null || hints.isEmpty()) {
            return Collections.emptyMap();
        }
        Map<String, String> hintMap = new HashMap<String, String>();
        for (MappingHint hint : hints) {
            hintMap.put(hint.type(), hint.content());
        }
        return hintMap;
    }

    private static boolean toBoolean(Boolean aBoolean, boolean dflt) {
        return aBoolean == null ? dflt : aBoolean;
    }

    private PhysSchema validatePhysicalSchema(
        MappingPhysicalSchema xmlPhysicalSchema,
        Handler handler,
        final Dialect dialect,
        final RolapSchema schema
    ) {
        if (xmlPhysicalSchema == null) {
            handler.error("Physical schema required");
            return null;
        }
        final PhysSchema physSchema =
            createSyntheticPhysicalSchema();

        // Create a table with 0 rows and 1 column. It is the basis for hanger
        // dimensions.
        final PhysInlineTable empty =
            new PhysInlineTable(
                physSchema, EMPTY_TABLE_NAME);
        final PhysRealColumn c =
            new PhysRealColumn(
                empty, EMPTY_TABLE_SOLE_COLUMN_NAME, Datatype.INTEGER,
                null, -1);
        empty.columnsByName.put(c.name, c);
        physSchema.tablesByName.put(empty.alias, empty);

        this.physSchemaBuilder = new PhysSchemaBuilder(null, physSchema);

        final Set<ElementDef> skip = new HashSet<ElementDef>();

        // First pass through elements, creating tables, ensuring that
        // table names are unique.
        // Register columns explicitly defined and also load columns from JDBC.
        // Collect calculated columns, to be resolved later.
        List<UnresolvedColumn> unresolvedColumnList =
            new ArrayList<UnresolvedColumn>();
        for (MappingPhysicalSchemaElement relation : xmlPhysicalSchema.children()) {
            final PhysRelationImpl physTable;
            if (relation instanceof MappingAutoGeneratedDateTable mappingAutoGeneratedDateTable) {
                String alias = mappingAutoGeneratedDateTable.alias();
                physTable =
                    registerTable(
                        handler,
                        dialect,
                        physSchema,
                        skip,
                        unresolvedColumnList,
                        mappingAutoGeneratedDateTable.alias(),
                        mappingAutoGeneratedDateTable);

                // If the table's alias is not unique, let the previous alias
                // stand; this table will be thrown away, but this check is after
                // the column and key validation so we can produce as many warnings
                // as possible.
                if (physSchema.tablesByName.containsKey(alias)) {
                    handler.warning(
                        "Duplicate table alias '" + alias + "'.");
                } else {
                    physSchema.tablesByName.put(alias, physTable);
                }

            } else {
                handler.warning(
                    "Invalid element '"
                        + "' in physical schema");
                continue;
            }

        }


        // Third pass, validate calculated columns. Note that a calculated
        // column can reference columns in other tables. Forward references
        // are allowed, but references must not be cyclic.
        for (UnresolvedColumn unresolvedColumn
            : unresolvedColumnList) {
            if (unresolvedColumn.getState()
                == UnresolvedColumn.State.RESOLVED) {
                continue;
            }
            resolve(physSchema, unresolvedColumn);
        }

        // Validate keys.
        for (PhysRelation table : physSchema.tablesByName.values()) {
            for (PhysKey key : table.getKeyList()) {
                for (PhysExpr keyColumn : key.columnList) {
                    if (keyColumn instanceof PhysCalcColumn) {
                        PhysCalcColumn physCalcColumn =
                            (PhysCalcColumn) keyColumn;
                        handler.warning(
                            "Key must not contain calculated column; calculated"
                                + " column '" + physCalcColumn.name
                                + "' in table '"
                                + physCalcColumn.relation.getAlias() + "'.");
                    } else if (keyColumn
                        instanceof UnresolvedColumn) {
                        // have already reported that it is unresolved: continue
                    } else {
                        PhysRealColumn column =
                            (PhysRealColumn) keyColumn;
                        if (column.relation != table) {
                            handler.warning(
                                "Columns in primary key must belong to key "
                                    + "table; in table '" + table.getAlias() + "'.");
                        }
                    }
                }
            }
        }

        return physSchema;
    }

    void resolve(
        PhysSchema physSchema,
        UnresolvedColumn unresolvedColumn
    ) {
        try {
            if (unresolvedColumn.getState() == UnresolvedColumn.State.ACTIVE) {
                getHandler().warning(
                    "Calculated column '" + unresolvedColumn.getName()
                        + "' in table '" + unresolvedColumn.getTableName()
                        + "' has cyclic expression", unresolvedColumn.getXml(), null);
                return;
            }
            unresolvedColumn.setState(UnresolvedColumn.State.ACTIVE);
            final PhysRelation table =
                physSchema.tablesByName.get(unresolvedColumn.getTableName());
            if (table == null) {
                getHandler().warning(
                    "Unknown table '" + unresolvedColumn.getTableName() + "'"
                        + unresolvedColumn.getContext() + ".",
                    null,
                    null);
                return;
            }
            final PhysColumn column =
                table.getColumn(
                    unresolvedColumn.getName(), false);
            if (column == null) {
                getHandler().warning(
                    "Reference to unknown column '" + unresolvedColumn.getName()
                        + "' in table '" + unresolvedColumn.getTableName() + "'"
                        + unresolvedColumn.getContext() + ".",
                    null,
                    null);
            } else {
                if (column instanceof PhysCalcColumn) {
                    PhysCalcColumn physCalcColumn =
                        (PhysCalcColumn) column;
                    for (Object o : physCalcColumn.list) {
                        if (o instanceof UnresolvedColumn) {
                            resolve(
                                physSchema,
                                (UnresolvedColumn) o);
                        }
                    }
                }
                unresolvedColumn.setState(UnresolvedColumn.State.RESOLVED);
                unresolvedColumn.onResolve(column);
            }
        } finally {
            if (unresolvedColumn.getState() == UnresolvedColumn.State.ACTIVE) {
                unresolvedColumn.setState(UnresolvedColumn.State.ERROR);
            }
        }
    }

    /**
     * Creates a physical schema for a user schema that has no PhysicalSchema
     * element. (Such a schema is referred to elsewhere as an
     * 'old-style schema'.)
     *
     * @return Physical schema
     */
    private PhysSchema createSyntheticPhysicalSchema() {
        return new PhysSchema(
            context,
            schema.getDialect(),
            schema.getInternalConnection());
    }

    /**
     * Converts an XML element or attribute into a list of columns.
     * If there is an error, logs it and returns null.
     */
    private List<PhysColumn> createColumnList(
        ElementDef xml,
        String attributeName,
        PhysRelation table,
        String columnName,
        MappingColumns xmlColumns
    ) {
        if (columnName != null) {
            if (xmlColumns != null) {
                // Post an error, and continue, ignoring xmlKey.
                getHandler().error(
                    "must not specify both "
                        + attributeName
                        + " and "
                        + xmlColumns.getName(),
                    xmlColumns,
                    null);
            }
            if (table == null) {
                getHandler().error(
                    "table must be specified",
                    xml,
                    attributeName);
                return Collections.emptyList();
            }
            PhysColumn column = table.getColumn(columnName, false);
            if (column == null) {
                getHandler().error(
                    "Column '" + columnName + "' not found in relation '"
                        + table.getAlias() + "'",
                    xml,
                    attributeName);
                return null;
            }
            return Collections.singletonList(column);
        }
        final List<PhysColumn> list =
            new ArrayList<PhysColumn>();
        if (xmlColumns != null) {
            for (MappingColumn xmlColumn : xmlColumns.array()) {
                PhysColumn column =
                    getPhysColumn(
                        last(table, xmlColumn.table(), xmlColumn, "table"),
                        xmlColumn.name(),
                        xmlColumn,
                        "name");
                if (column == null) {
                    return null;
                }
                list.add(column);
            }
        }
        return list;
    }

    private PhysTable registerTable(
        Handler handler,
        Dialect dialect,
        PhysSchema physSchema,
        Set<ElementDef> skip,
        List<UnresolvedColumn> unresolvedColumnList,
        String alias,
        MappingAutoGeneratedDateTable xmlTable
    ) {
        final PhysTable physTable =
            new PhysTable(
                physSchema,
                xmlTable.schema(),
                xmlTable.name(),
                alias,
                buildHintMap(xmlTable.hints()));

        if (xmlTable instanceof MappingAutoGeneratedDateTable) {
            registerAutoDateTable(handler, xmlTable, physTable);
            physTable.ensurePopulated(this, xmlTable);
        } else {
            // Read columns from JDBC.
            physTable.ensurePopulated(this, xmlTable);
            // First pass, register columns. We will resolve and
            // register keys later.
            for (MappingColumnDef xmlColumn
                : getColumnDefs(xmlTable.tableElement())) {
                registerColumn(
                    handler,
                    dialect,
                    skip,
                    unresolvedColumnList,
                    alias,
                    physTable,
                    xmlColumn);
            }
        }

        registerKey(
            handler, xmlTable, xmlTable.column(), null, unresolvedColumnList,
            physTable);
        for (MappingKey key : xmlTable.keys()) {
            registerKey(
                handler, xmlTable, null, key, unresolvedColumnList, physTable);
        }
        return physTable;
    }

    static class Tcl {
        private final String table;
        private final String column;
        private final MappingColumn xml;

        Tcl(String table, String column, MappingColumn xml) {
            this.table = table;
            this.column = column;
            this.xml = xml;
        }
    }

    private void registerKey(
        Handler handler,
        ElementDef xmlTable,
        String columnName,
        final MappingKey xmlKey,
        List<UnresolvedColumn> unresolvedColumnList,
        final PhysRelationImpl physTable)
    {
        String keyName;
        List<Tcl> columns;
        if (xmlKey == null) {
            if (columnName == null) {
                // If both null, nothing to do.
                return;
            }
            columns = Collections.singletonList(
                new Tcl(null, columnName, xmlTable));
            keyName = "primary";
        } else {
            columns = new AbstractList<Tcl>() {
                public Tcl get(int index) {
                    MappingColumn column = xmlKey.columns().get(index);
                    return new Tcl(column.table(), column.name(), column);
                }

                public int size() {
                    return xmlKey.columns().size();
                }
            };
            keyName = xmlKey.name();
            if (keyName == null) {
                keyName = "primary";
            }
        }
        if (physTable.lookupKey(keyName) != null) {
            handler.error(
                "Table has more than one key with name '" + keyName
                    + "'");
            return;
        }
        final PhysKey key =
            physTable.addKey(
                keyName, new ArrayList<PhysColumn>());
        int i = 0;
        for (Tcl columnRef : columns) {
            final int index = i++;
            final UnresolvedColumn unresolvedColumn =
                new UnresolvedColumn(
                    physTable,
                    columnRef.table() != null
                        ? columnRef.table()
                        : physTable.alias,
                    columnRef.column,
                    columnRef.xml)
                {
                    public void onResolve(PhysColumn column) {
                        assert column != null;
                        key.columnList.set(index, column);
                    }

                    public String getContext() {
                        return ", in key of table '"
                            + physTable.alias + "'";
                    }
                };
            key.columnList.add(unresolvedColumn);
            unresolvedColumnList.add(unresolvedColumn);
        }
        if (key.columnList.size() != 1) {
            handler.warning(
                "Key must have precisely one column; key "
                    + key.columnList
                    + " in table '"
                    + physTable.alias + "'.");
        }
    }


    private void registerColumn(
        Handler handler,
        Dialect dialect,
        Set<ElementDef> skip,
        List<UnresolvedColumn> unresolvedColumnList,
        String alias,
        PhysRelationImpl physRelation,
        MappingColumnDef xmlColumn
    ) {
        boolean inlineTable =
            physRelation instanceof PhysInlineTable;
        boolean calcColDef =
            xmlColumn instanceof MappingCalculatedColumnDef;
        if ((inlineTable || calcColDef)
            && physRelation.columnsByName.containsKey(xmlColumn.name())) {
            // The calc or inlined column is a duplicate.
            handler.warning(
                "Duplicate column '" + xmlColumn.name()
                    + "' in table '" + alias + "'.");
            skip.add(xmlColumn);
            return;
        }
        if (inlineTable) {
            PhysInlineTable physInlineTable =
                (PhysInlineTable) physRelation;
            if (calcColDef) {
                handler.warning(
                    "Cannot define calculated column in inline table");
            } else {
                PhysRealColumn physColumn =
                    new PhysRealColumn(
                        physInlineTable,
                        xmlColumn.name(),
                        toType(xmlColumn.type()),
                        toInternalType(xmlColumn.internalType()),
                        -1);
                physInlineTable.addColumn(physColumn);
            }
            return;
        }
        final PhysTable physTable =
            (PhysTable) physRelation;
        if (calcColDef) {
            MappingCalculatedColumnDef xmlCalcColumnDef =
                (MappingCalculatedColumnDef) xmlColumn;
            final List<PhysExpr> list =
                new ArrayList<PhysExpr>();
            final PhysCalcColumn physCalcColumn =
                new PhysCalcColumn(
                    this,
                    xmlCalcColumnDef,
                    physTable,
                    xmlColumn.name(),
                    toType(xmlColumn.type()),
                    toInternalType(xmlColumn.internalType()),
                    list);

            final MappingSQL sql;
            assert xmlCalcColumnDef.expression() != null;
            if (xmlCalcColumnDef.expression()
                instanceof MappingExpressionView) {
                MappingExpressionView expressionView =
                    (MappingExpressionView)
                        xmlCalcColumnDef.expression();
                sql = MappingSQL.choose(
                    expressionView.expressions(),
                    dialect);
            } else {
                // Create dummy wrapper so it looks as if the
                // column is part of a collection of SQL
                // choices.
                sql = new SQLR();
                sql.children =
                    new NodeDef[]{
                        (MappingColumn)
                            xmlCalcColumnDef.expression()
                    };
            }
            for (int i = 0; i < sql.children.length; i++) {
                NodeDef child = sql.children[i];
                if (child instanceof TextDef) {
                    TextDef text = (TextDef) child;
                    String s = text.getText();
                    s = trim(s, i == 0, i == sql.children.length - 1);
                    list.add(new PhysTextExpr(s));
                } else if (child instanceof MappingColumn) {
                    final int index = list.size();
                    final MappingColumn columnRef =
                        (MappingColumn) child;
                    final UnresolvedColumn unresolvedColumn =
                        new UnresolvedCalcColumn(
                            physTable,
                            first(columnRef.table(), alias),
                            columnRef,
                            sql,
                            physCalcColumn,
                            list,
                            index);
                    list.add(unresolvedColumn);
                    unresolvedColumnList.add(unresolvedColumn);
                } else {
                    throw new IllegalArgumentException(
                        "illegal expression: " + child);
                }
            }
            physCalcColumn.compute();
            physTable.addColumn(physCalcColumn);
        } else {
            // Check that column exists; throw if not.
            PhysColumn physColumn =
                physRelation.getColumn(
                    xmlColumn.name(),
                    true);
            if (xmlColumn.type() != null) {
                physColumn.setDatatype(
                    toType(xmlColumn.type()));
            }
            if (xmlColumn.internalType() != null) {
                physColumn.setInternalType(
                    toInternalType(xmlColumn.internalType()));
            }
        }
    }

    private Datatype toType(TypeEnum type) {
            return Datatype.fromValue(type.getValue());
    }

    private void registerAutoDateTable(
        Handler handler,
        MappingPhysicalSchemaElement xmlTable,
        PhysTable physTable
    ) {
        MappingAutoGeneratedDateTable xmlDateTable =
            (MappingAutoGeneratedDateTable) xmlTable;
        final Map<String, TimeColumnRole.Struct> columnRoleMap =
            new HashMap<String, TimeColumnRole.Struct>();
        List<MappingColumnDef> xmlColumnDefs;
        if (hasColumnDefs(xmlDateTable.tableElement())) {
            xmlColumnDefs = getColumnDefs(xmlDateTable.tableElement());
        } else {
            xmlColumnDefs =
                new ArrayList<MappingColumnDef>();
            for (TimeColumnRole role : TimeColumnRole.values()) {
                MappingColumnDef xmlColumnDef =
                    new ColumnDefR(new TimeDomainR(role.name(), null), role.columnName,
                        TypeEnum.fromValue(role.defaultDatatype.name()));
                xmlColumnDefs.add(xmlColumnDef);
            }
        }
        for (MappingColumnDef xmlColumnDef : xmlColumnDefs) {
            MappingTimeDomain domain =
                xmlColumnDef.timeDomain();
            TimeColumnRole.Struct struct;
            if (domain != null) {
                TimeColumnRole role =
                    Util.lookup(
                        TimeColumnRole.class, domain.role().toUpperCase());
                if (role == null) {
                    handler.error(
                        "Bad role '" + domain + "', in column '"
                            + xmlColumnDef.name() + "'. Allowable roles are "
                            + Arrays.toString(TimeColumnRole.values()));
                    continue;
                }
                struct =
                    new TimeColumnRole.Struct(
                        role,
                        parseDate(domain.epoch(), domain, "epoch"));
            } else {
                TimeColumnRole role =
                    TimeColumnRole.mapNameToRole.get(
                        xmlColumnDef.name().toUpperCase());
                if (role == null) {
                    handler.error(
                        "Each column in an auto-generated date table must "
                            + "either have a nested <TimeDomain> element, or "
                            + "have a standard name such as 'the_month'; "
                            + "column '" + xmlColumnDef.name() + "' is neither");
                    continue;
                }
                struct = new TimeColumnRole.Struct(role, null);
            }
            if (xmlColumnDef.type() == null) {
                xmlColumnDef.setType(struct.role.defaultDatatype.name());
            }
            columnRoleMap.put(xmlColumnDef.name(), struct);
        }
        Instant startDate = xmlDateTable.startDate();
        Instant endDate = xmlDateTable.endDate();
        //endDate
        if (startDate == null || endDate == null) {
            // parseDate has posted an error. Soldier on...
            return;
        }
        physTable.setHook(
            new DateTableBuilder(
                columnRoleMap,
                xmlColumnDefs, startDate, endDate));
    }


    /**
     * Parses a date in "yyyy-MM-dd" format (e.g. "2012-02-21").
     *
     * <p>If date is
     * not valid, posts an error and returns null.</p>
     *
     * <p>If date is null, returns null.</p>
     *
     * @param dateString    Date string
     * @param node          XML node
     * @param attributeName XML attribute
     * @return Parsed date, or null if date string is null or not valid
     */
    private java.sql.Date parseDate(
        String dateString,
        MappingTimeDomain node,
        String attributeName
    ) {
        if (dateString == null) {
            return null;
        }
        try {
            Date date = SIMPLE_DATE_FORMAT.parse(dateString);
            return new java.sql.Date(date.getTime());
        } catch (ParseException e) {
            handler.error(
                "Invalid date '" + dateString + "'");
            return null;
        }
    }

    public Handler getHandler() {
        return handler;
    }

    /**
     * Returns whether there is a &lt;ColumnDefs&gt; element among
     * {@code children}.
     *
     * @param children Array of child nodes
     * @return Whether there is a ColumnDefs
     */
    private boolean hasColumnDefs(List<MappingTableElement> children) {
        for (MappingTableElement child : children) {
            if (child instanceof MappingColumnDefs) {
                return true;
            }
        }
        return false;
    }

    private List<MappingColumnDef> getColumnDefs(List<MappingTableElement> children) {
        List<MappingColumnDef> result = new ArrayList<>();
        for (MappingTableElement child : children) {
            if (child instanceof MappingColumnDefs mappingColumnDefs) {
                result.addAll(mappingColumnDefs.columnDefs());
            }
        }
        return result;

    }

    public RolapSchema getSchema() {
        return schema;
    }
}
